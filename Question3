#Install the packages below
# !pip install pandas
# !pip install numpy
# !pip install pandas-datareader
# !pip install arch

# Import these packages
import pandas as pd
import numpy as np
import pandas_datareader.data as pdr
import arch

# A
Bitcoin = pdr.get_data_yahoo("BTC-USD", start="2022-04-26", end="2022-07-26")
print(Bitcoin.columns)
# Create new variable name stock_data
stock_data = Bitcoin[['Close']]
stock_data["log"] = np.log(stock_data)-np.log(stock_data.shift(1))
stock_data.tail(10)
stock_data.describe()
#Show the value of historical volatility
# 1st method
print(stock_data.log.std())
# 2nd method
log_returns = np.log(stock_data.Close/stock_data.Close.shift(1))
#print(log_returns)
sum_log_returns = 0
mean_log_returns = log_returns.mean()
for i in range(1,len(log_returns)):
    sum_log_returns += (log_returns.iloc[i]-mean_log_returns)**2
variance = sum_log_returns/(len(log_returns)-1)
vol = np.sqrt(variance)
print(vol)
# 3rd method
print(np.std(stock_data.log))

# Actual volatility value might equal to the historical volatility.Because, historical volatility is a subset of Actual volatility.
#For the stochastic volatility,will be use ARCH model.
model = arch.arch_model(stock_data["log"].dropna(), mean='Zero', vol='GARCH', p=1, q=1)
model_fit = model.fit()
forecast = model_fit.forecast(horizon = 1) 
var = forecast.variance.iloc[-1]
# print(var)
sigma = float(np.sqrt(var))
print(sigma)

# Compute implied volatility
import scipy.stats
from numpy import sqrt, log, exp, pi

N = scipy.stats.norm.cdf
ONE_CENT = 0.01
step = 0.0001
N_price = scipy.stats.norm.pdf
MAX_TRY = 1000

def bs_price(S, K, r, t, sigma):
    d1 = (log(S/K) + (r+sigma**2/2)*t) / (sigma*sqrt(t))
    d2 = d1 - sigma * sqrt(t)
    Put_Price = N(-d2) * K * exp(-r*t) - N(-d1) * S 
    return Put_Price,d1,d2 

def brute_force(S, K, r, t, market_price):
    _sigma = 0.5
    for i in range(10000): #max number of calculations is 10000
        Put_Price = bs_price(S, K, r, t, sigma = _sigma)
        diff = market_price - Put_Price[0]
        if diff > ONE_CENT:
            _sigma = _sigma + step
        elif diff < 0 and abs(diff) > ONE_CENT:
            _sigma = _sigma - step
        elif abs(diff) < ONE_CENT:
            return _sigma
    return _sigma
sigma = brute_force(21500,17200,0.02,30/365, 21239.75)
print(sigma)

# B
'''Actual Volatility
     This is the measure of the amount of randomness in an asset return at any particular time. It is very difficult to measure, but is supposed to be an input into all option pricing models.
• There is no ‘timescale’ associated with actual volatility; it is a quantity that exists at each instant, possibly 
varying from moment to moment.
Historical Volatility
    This is a measure of the amount of randomness over some period in the past. The period is always specified, and so 
    is the mathematical method for its calculation. Sometimes this backward-looking measure is used as an estimate for 
    what volatility will be in the future.
    • There are two ‘timescales’ associated with historical volatility: one short, and one long.
Example: The 60-day volatility using daily returns. Perhaps of interest if you are pricing a 60-day option, which you are hedging daily.In pricing an option we are making an estimate of what actual volatility will be over the lifetime of the option. After the option has expired we can go back and calculate what the volatility actually was over the life of the option.

  Example: I sold a 30-day option for a 30% volatility, I hedged it every day. Did I make money?
Implied Volatility
The implied volatility is the volatility which when input into the Black–Scholes option pricing formulae gives the       market price of the option. It is often described as the market’s view of the future actual volatility over the lifetime of the particular option. However, it is also influenced by other effects such as supply and demand. 
• There is one ‘timescale’ associated with implied volatility: expiration.
Stochastic Volatility
refers to the fact that the volatility of asset prices varies and is not constant, as is assumed in the Black Scholes options pricing model. Stochastic volatility modeling attempts to correct for this problem with Black Scholes by allowing volatility to fluctuate over time.'''

# C Pricing Put Option
# i) Black Schles Model
from scipy.stats import norm 
import matplotlib.pyplot as plt

def calculate_put_option_price(S,T,r,sigma): 
    """
    Calculates price for put option according to the formula.        
    Formula: PresentValue(K)*N(-d2) - S*N(-d1)
    """
    T /= 365
    K = 0.8*S
    # cumulative function of standard normal distribution (risk-adjusted probability that the option will be exercised)    
    d1 = (np.log(S/K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))

    # cumulative function of standard normal distribution (probability of receiving the stock at expiration of the option)
    d2 = (np.log(S/K) + (r - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))

    return (K * np.exp(-r * T) * norm.cdf(-d2, 0.0, 1.0) - S * norm.cdf(-d1, 0.0, 1.0))
 
S_0 = 21500
T = 30
r = 0.02
sigma = 1.5
Put_Price = calculate_put_option_price(S_0,T,r,sigma)
print(Put_Price)

# ii)Finite Difference Method
from mpl_toolkits.mplot3d import Axes3D
import scipy.sparse

def bottom_boundary_condition(K,T, r, t):
    return K*np.exp(-r*(T-t))
def top_boundary_condition(t):
    return np.zeros(t.shape)
def final_boundary_condition(K,S):
    return np.maximum(K-S,0)
def compute_abc( K, T, sigma, r, S, dt, dS ):
    a = -sigma**2 * S**2/(2* dS**2 ) + r*S/(2*dS)
    b = r + sigma**2 * S**2/(dS**2)
    c = -sigma**2 * S**2/(2* dS**2 ) - r*S/(2*dS)
    return a,b,c
def compute_lambda( a,b,c ):
    return scipy.sparse.diags( [a[1:],b,c[:-1]],offsets=[-1,0,1])
def compute_W(a,b,c, V0, VM): 
    M = len(b)+1
    W = np.zeros(M-1)
    W[0] = a[0]*V0 
    W[-1] = c[-1]*VM 
    return W
def price_call_explicit( K, T, r, sigma, N, M):
    # Choose the shape of the grid
    dt = T/N
    S_min=0
    S_max=K*np.exp(8*sigma*np.sqrt(T))
    dS = (S_max-S_min)/M
    S = np.linspace(S_min,S_max,M+1)
    t = np.linspace(0,T,N+1)
    V = np.zeros((N+1,M+1)) #...
    
    # Set the boundary conditions
    V[:,-1] = top_boundary_condition(t)
    V[:,0] = bottom_boundary_condition(K,T, r, t)
    V[-1,:] = final_boundary_condition(K,S) #...
    
    # Apply the recurrence relation
    a,b,c = compute_abc(K,T,sigma,r,S[1:-1],dt,dS)
    Lambda =compute_lambda( a,b,c) 
    identity = scipy.sparse.identity(M-1)
    
    for i in range(N,0,-1):
        W = compute_W(a,b,c,V[i,0],V[i,M])
        # Use `dot` to multiply a vector by a sparse matrix
        V[i-1,1:M] = (identity-Lambda*dt).dot( V[i,1:M] ) - W*dt
        
    return V, t, S
K = 17200  #0.8*21500
T = 30/365
r = 0.02
sigma =1.5
N = 50
M = 50
price_call_explicit( K, T, r, sigma, N, M)
# iii) Monte Carlo Simulation
 def MonteCarloPricing(S_0,T,r,sigma,N):
    num_of_steps = T
    T /= 365
    K = 0.8*S_0
    dt = T/num_of_steps
    
    np.random.seed(20)
    simulation_results = None

    # Initializing price movements for simulation: rows as time index and columns as different random price movements.
    S = np.zeros((num_of_steps,N))        
    # Starting value for all price movements is the current spot price
    S[0] = S_0

    for t in range(1,num_of_steps):
        # Random values to simulate Brownian motion (Gaussian distibution)
        Z = np.random.standard_normal(N)
        # Updating prices for next point in time 
        S[t] = S[t - 1] * np.exp((r - 0.5*sigma ** 2) * dt + (sigma * np.sqrt(dt) * Z))

    simulation_results_S = S
    
    if simulation_results_S is None:
            return -1
    return np.exp(-r*T) * 1/N * np.sum(np.maximum(K - simulation_results_S[-1], 0))
    
S_0 = 21500
T = 30
r = 0.02
sigma = 1.5
N = 10000
print(MonteCarloPricing(S_0,T,r,sigma,N)) 
# 1)I decide to use implied volatility to calculated.Because,it's the highest value.

# iv)

